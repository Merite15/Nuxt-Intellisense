import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.languages.registerCodeLensProvider(
            [
                { language: 'vue' },
                { language: 'typescript' },
                { language: 'javascript' }
            ],
            new NuxtIntellisense()
        )
    );

    console.log('Extension "nuxt intellisense" activate!');
}

interface NuxtComponentInfo {
    name: string;
    path: string;
    isAutoImported: boolean;
    exportType?: string;
}

class NuxtIntellisense implements vscode.CodeLensProvider {
    private nuxtProjectRoot: string | null = null;

    private autoImportCache: Map<string, NuxtComponentInfo[]> = new Map();

    private lastCacheUpdate: number = 0;

    private cacheUpdateInterval: number = 30000;

    async provideCodeLenses(document: vscode.TextDocument): Promise<vscode.CodeLens[]> {
        const lenses: vscode.CodeLens[] = [];

        const fileName = path.basename(document.fileName);

        if (fileName === 'app.vue' || fileName === 'error.vue') {
            return [];
        }

        this.nuxtProjectRoot = await this.findNuxtProjectRoot(document.uri);

        await this.updateAutoImportCacheIfNeeded();

        // Le nom du fichier actuel (pour d√©terminer le type)
        const fileDir = path.dirname(document.fileName);
        const fileExtension = path.extname(document.fileName);
        const isVueFile = fileExtension === '.vue';
        const isComposable = fileDir.includes('composables');
        const isComponent = fileDir.includes('components');
        const isPlugin = fileDir.includes('plugins');
        const isMiddleware = fileDir.includes('middleware');
        const isPages = fileDir.includes('pages');
        const isLayout = fileDir.includes('layouts');
        const isStore = fileDir.includes('stores') || fileDir.includes('store');

        const text = document.getText();

        // 1. D√©tection des composables (dans /composables/*.ts)
        if (isComposable) {
            const composableRegex = /export\s+(const|function|async function)\s+(\w+)/g;
            let match: RegExpExecArray | null;

            while ((match = composableRegex.exec(text))) {
                const funcType = match[1];
                const name = match[2];
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // Rechercher les r√©f√©rences, y compris les auto-importations
                const references = await this.findAllReferences(document, name, pos);
                const referenceCount = references.length;

                const autoImportInfo = isComposable ? "auto-import√©" : "";

                lenses.push(
                    new vscode.CodeLens(range, {
                        title: `üîÑ ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                        command: 'editor.action.showReferences',
                        arguments: [
                            document.uri,
                            new vscode.Position(pos.line, match[0].indexOf(name)),
                            references
                        ]
                    })
                );
            }
        }

        // 2. D√©tection des composants Vue et Nuxt (dans /components/*.vue)
        if (isVueFile) {
            // Ne pas afficher les CodeLens pour les composants si on est dans une page

            const isPagesComponents = document.fileName.includes(`${path.sep}pages${path.sep}`) && document.fileName.includes(`${path.sep}components${path.sep}`);

            if ((!isPages || isPagesComponents) && !isLayout) {
                let hasAddedLens = false;

                // 2.1 Pour les composants avec <script setup>
                const scriptSetupRegex = /<script\s+[^>]*setup[^>]*>/g;
                let match: RegExpExecArray | null;

                // D'abord chercher le script setup
                while ((match = scriptSetupRegex.exec(text))) {
                    const pos = document.positionAt(match.index);
                    const range = new vscode.Range(pos.line, 0, pos.line, 0);

                    // Nom du composant bas√© sur le nom de fichier
                    const componentName = path.basename(document.fileName, '.vue');

                    // Rechercher les r√©f√©rences, y compris les auto-importations
                    const references = await this.findComponentReferences(document, componentName);
                    const referenceCount = references.length;

                    const autoImportInfo = isComponent ? "auto-import√©" : "";

                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üß© ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                            command: 'editor.action.showReferences',
                            arguments: [
                                document.uri,
                                pos,
                                references
                            ]
                        })
                    );
                    hasAddedLens = true;
                }

                // 2.2 Pour les composants avec defineComponent (seulement si pas de script setup trouv√©)
                if (!hasAddedLens) {
                    const defineComponentRegex = /defineComponent\s*\(/g;
                    while ((match = defineComponentRegex.exec(text))) {
                        const pos = document.positionAt(match.index);
                        const range = new vscode.Range(pos.line, 0, pos.line, 0);

                        // Nom du composant bas√© sur le nom de fichier
                        const componentName = path.basename(document.fileName, '.vue');

                        // Rechercher les r√©f√©rences, y compris les auto-importations
                        const references = await this.findComponentReferences(document, componentName);
                        const referenceCount = references.length;

                        lenses.push(
                            new vscode.CodeLens(range, {
                                title: `üß© ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                                command: 'editor.action.showReferences',
                                arguments: [
                                    document.uri,
                                    pos,
                                    references
                                ]
                            })
                        );
                        hasAddedLens = true;
                    }
                }

                // 2.3 Pour les composants Nuxt sp√©cifiques (seulement si pas de script setup trouv√©)
                if (!hasAddedLens) {
                    const defineNuxtComponentRegex = /defineNuxtComponent\s*\(/g;
                    while ((match = defineNuxtComponentRegex.exec(text))) {
                        const pos = document.positionAt(match.index);
                        const range = new vscode.Range(pos.line, 0, pos.line, 0);

                        // Nom du composant bas√© sur le nom de fichier
                        const componentName = path.basename(document.fileName, '.vue');

                        // Rechercher les r√©f√©rences, y compris les auto-importations
                        const references = await this.findComponentReferences(document, componentName);
                        const referenceCount = references.length;

                        lenses.push(
                            new vscode.CodeLens(range, {
                                title: `‚ö° ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                                command: 'editor.action.showReferences',
                                arguments: [
                                    document.uri,
                                    pos,
                                    references
                                ]
                            })
                        );
                        hasAddedLens = true;
                    }
                }

                // 2.4 Si aucune des m√©thodes ci-dessus n'a trouv√© de balise, chercher la balise template
                if (!hasAddedLens) {
                    const templateRegex = /<template[^>]*>/g;
                    match = templateRegex.exec(text);

                    if (match) {
                        const pos = document.positionAt(match.index);
                        const range = new vscode.Range(pos.line, 0, pos.line, 0);

                        // Nom du composant bas√© sur le nom de fichier
                        const componentName = path.basename(document.fileName, '.vue');

                        // Rechercher les r√©f√©rences, y compris les auto-importations
                        const references = await this.findComponentReferences(document, componentName);
                        const referenceCount = references.length;

                        const autoImportInfo = isComponent ? "auto-import√©" : "";

                        lenses.push(
                            new vscode.CodeLens(range, {
                                title: `üß© ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                                command: 'editor.action.showReferences',
                                arguments: [
                                    document.uri,
                                    pos,
                                    references
                                ]
                            })
                        );
                    }
                }
            }
        }

        // 3. D√©tection des plugins Nuxt (dans /plugins/*.ts)
        if (isPlugin) {
            const defineNuxtPluginRegex = /defineNuxtPlugin\s*\(/g;
            let match: RegExpExecArray | null;

            while ((match = defineNuxtPluginRegex.exec(text))) {
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // Nom du plugin bas√© sur le nom de fichier
                const pluginName = path.basename(document.fileName, path.extname(document.fileName));

                // Rechercher les r√©f√©rences
                const references = await this.findPluginReferences(pluginName);
                const referenceCount = references.length;

                lenses.push(
                    new vscode.CodeLens(range, {
                        title: `üîå ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                        command: 'editor.action.showReferences',
                        arguments: [
                            document.uri,
                            pos,
                            references
                        ]
                    })
                );
            }
        }

        // 4. D√©tection des middleware Nuxt (dans /middleware/*.ts)
        if (isMiddleware) {
            const defineNuxtMiddlewareRegex = /defineNuxtRouteMiddleware\s*\(/g;
            let match: RegExpExecArray | null;

            while ((match = defineNuxtMiddlewareRegex.exec(text))) {
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // Nom du middleware bas√© sur le nom de fichier
                const middlewareName = path.basename(document.fileName, path.extname(document.fileName));

                // V√©rifier si c'est un middleware global
                const isGlobal = document.fileName.includes('.global.');

                if (isGlobal) {
                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üåç Global Middleware`,
                            command: ''
                        })
                    );
                } else {
                    // Rechercher les r√©f√©rences seulement si ce n'est pas un middleware global
                    const references = await this.findMiddlewareReferences(middlewareName);
                    const referenceCount = references.length;

                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üîó ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                            command: 'editor.action.showReferences',
                            arguments: [
                                document.uri,
                                pos,
                                references
                            ]
                        })
                    );
                }
            }
        }

        // 5. D√©tection des layouts Nuxt (dans /layouts/*.vue)
        if (isLayout) {
            const layoutSetupRegex = /<script\s+setup[^>]*>|<template>/g;
            let match: RegExpExecArray | null;

            if ((match = layoutSetupRegex.exec(text))) {
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // Nom du layout bas√© sur le nom de fichier
                const layoutName = path.basename(document.fileName, '.vue');

                // Rechercher les r√©f√©rences
                const references = await this.findLayoutReferences(layoutName);
                const referenceCount = references.length;

                if (layoutName === 'default') {
                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üñºÔ∏è Default Layout`,
                            command: ''
                        })
                    );
                } else if (referenceCount > 0) {
                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üñºÔ∏è ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                            command: 'editor.action.showReferences',
                            arguments: [
                                document.uri,
                                pos,
                                references
                            ]
                        })
                    );
                }
            }
        }

        // 6. D√©tection des stores Pinia (dans /stores/*.ts)
        if (isStore) {
            const defineStoreRegex = /defineStore\s*\(\s*(['"`])(.*?)\1/g;
            let match: RegExpExecArray | null;

            while ((match = defineStoreRegex.exec(text))) {
                const storeName = match[2];
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // V√©rification que c'est bien un fichier de store
                if (document.uri.fsPath.includes(path.sep + 'stores' + path.sep)) {
                    // Obtenir les r√©f√©rences PR√âCISES
                    const preciseReferences = await this.findStoreReferences(storeName);
                    const uniqueReferences = this.removeDuplicateReferences(preciseReferences);
                    const referenceCount = uniqueReferences.length;

                    lenses.push(
                        new vscode.CodeLens(range, {
                            title: `üóÉÔ∏è ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                            command: 'editor.action.showReferences',
                            arguments: [
                                document.uri,
                                new vscode.Position(pos.line, match[0].indexOf(storeName)),
                                uniqueReferences
                            ]
                        })
                    );
                }
            }
        }

        // 7. D√©tection des imports de fichiers (dans /utils/*.ts)
        const isUtils = fileDir.includes('utils') ||
            fileDir.includes('constants') ||
            fileDir.includes('schemas') ||
            fileDir.includes('validationSchemas') ||
            fileDir.includes('helpers') ||
            fileDir.includes('lib');

        if (isUtils && !isComposable && !isStore) {
            const utilsRegex = /export\s+(const|function|async function|interface|type|enum|class)\s+(\w+)/g;
            let match: RegExpExecArray | null;

            while ((match = utilsRegex.exec(text))) {
                const exportType = match[1];
                const name = match[2];
                const pos = document.positionAt(match.index);
                const range = new vscode.Range(pos.line, 0, pos.line, 0);

                // Type d'emoji et libell√© selon le type d'export
                let emoji = 'üîß'; // Par d√©faut pour les utilitaires
                let typeLabel = 'utilitaire';

                if (exportType === 'interface' || exportType === 'type') {
                    emoji = 'üìù';
                    typeLabel = exportType === 'interface' ? 'interface' : 'type';
                } else if (exportType === 'const') {
                    emoji = 'üìä';
                    typeLabel = 'constante';
                } else if (exportType === 'class') {
                    emoji = 'üèõÔ∏è';
                    typeLabel = 'classe';
                }

                // Rechercher les r√©f√©rences
                const references = await this.findUtilsReferences(document, name, pos);
                const referenceCount = references.length;

                lenses.push(
                    new vscode.CodeLens(range, {
                        title: `${emoji} ${referenceCount} reference${referenceCount > 1 ? 's' : ''}`,
                        command: 'editor.action.showReferences',
                        arguments: [
                            document.uri,
                            new vscode.Position(pos.line, match[0].indexOf(name)),
                            references
                        ]
                    })
                );
            }
        }

        return lenses;
    }

    private removeDuplicateReferences(references: vscode.Location[]): vscode.Location[] {
        const uniqueRefs: vscode.Location[] = [];
        const seen = new Set<string>();

        for (const ref of references) {
            const key = `${ref.uri.fsPath}:${ref.range.start.line}:${ref.range.start.character}`;
            if (!seen.has(key)) {
                seen.add(key);
                uniqueRefs.push(ref);
            }
        }

        return uniqueRefs;
    }

    /**
     * Trouvez la racine du projet Nuxt
     */
    private async findNuxtProjectRoot(uri: vscode.Uri): Promise<string | null> {
        let currentDir = path.dirname(uri.fsPath);
        const root = path.parse(currentDir).root;

        while (currentDir !== root) {
            const nuxtConfigPath = path.join(currentDir, 'nuxt.config.ts');
            const nuxtConfigJsPath = path.join(currentDir, 'nuxt.config.js');

            try {
                if (fs.existsSync(nuxtConfigPath) || fs.existsSync(nuxtConfigJsPath)) {
                    return currentDir;
                }
            } catch (e) {
                // Ignorer les erreurs
            }

            currentDir = path.dirname(currentDir);
        }

        return null;
    }

    /**
     * Mettre √† jour le cache des auto-importations si n√©cessaire
     */
    private async updateAutoImportCacheIfNeeded(): Promise<void> {
        const now = Date.now();
        if (now - this.lastCacheUpdate < this.cacheUpdateInterval) {
            return;
        }

        this.lastCacheUpdate = now;
        await this.updateAutoImportCache();
    }

    /**
     * Mettre √† jour le cache des auto-importations
     */
    private async updateAutoImportCache(): Promise<void> {
        if (!this.nuxtProjectRoot) {
            return;
        }

        // R√©initialiser le cache
        this.autoImportCache.clear();

        // Analyser les composants
        const componentDirs = await this.findAllDirsByName('components');
        for (const dir of componentDirs) {
            await this.scanComponentsDirectory(dir);
        }

        // Analyser les composables
        const composablesDirs = await this.findAllDirsByName('composables');
        for (const dir of composablesDirs) {
            await this.scanComposablesDirectory(dir);
        }

        // Analyser les stores
        const storeDirs = await this.findAllDirsByName('stores');
        for (const dir of storeDirs) {
            await this.scanStoresDirectory(dir);
        }

        // Analyser les utilitaires et constantes
        await this.scanUtilsDirectories();
    }

    /**
     * Analyser le r√©pertoire des composants
     */
    private async scanComponentsDirectory(dir: string): Promise<void> {
        if (!fs.existsSync(dir)) {
            return;
        }

        const componentInfos: NuxtComponentInfo[] = [];
        const relativePattern = new vscode.RelativePattern(dir, '**/*.vue');
        const files = await vscode.workspace.findFiles(relativePattern);

        for (const file of files) {
            const componentName = path.basename(file.fsPath, '.vue');
            componentInfos.push({
                name: componentName,
                path: file.fsPath,
                isAutoImported: true
            });
        }

        this.autoImportCache.set('components', componentInfos);
    }

    /**
     * Analyser le r√©pertoire des composables
     */
    private async scanComposablesDirectory(dir: string): Promise<void> {
        if (!fs.existsSync(dir)) {
            return;
        }

        const composableInfos: NuxtComponentInfo[] = [];
        const relativePattern = new vscode.RelativePattern(dir, '**/*.{ts,js}');
        const files = await vscode.workspace.findFiles(relativePattern);

        for (const file of files) {
            try {
                const content = fs.readFileSync(file.fsPath, 'utf-8');
                // Ignorer compl√®tement les fichiers qui ne sont pas dans le dossier composables
                if (!file.fsPath.includes(path.sep + 'composables' + path.sep)) {
                    continue;
                }

                // V√©rifier si le fichier contient une d√©finition de store Pinia
                if (content.includes('defineStore')) {
                    continue;
                }

                const exportRegex = /export\s+(const|function|async function)\s+(\w+)/g;
                let match: RegExpExecArray | null;
                while ((match = exportRegex.exec(content))) {
                    const name = match[2];
                    composableInfos.push({
                        name: name,
                        path: file.fsPath,
                        isAutoImported: true
                    });
                }
            } catch (e) {
                // Ignorer les erreurs de lecture
            }
        }
        this.autoImportCache.set('composables', composableInfos);
    }

    /**
     * Analyser le r√©pertoire des stores
     */
    private async scanStoresDirectory(dir: string): Promise<void> {
        if (!fs.existsSync(dir)) return;

        const storeInfos: NuxtComponentInfo[] = [];
        const relativePattern = new vscode.RelativePattern(dir, '**/*.{ts,js}');
        const files = await vscode.workspace.findFiles(relativePattern);

        for (const file of files) {
            try {
                const content = fs.readFileSync(file.fsPath, 'utf-8');
                const defineStoreRegex = /defineStore\s*\(\s*(['"`])(.*?)\1/g;
                let match: RegExpExecArray | null;

                while ((match = defineStoreRegex.exec(content))) {
                    storeInfos.push({
                        name: match[2],
                        path: file.fsPath,
                        isAutoImported: true
                    });
                }
            } catch (e) {
                console.error(`Error reading store file ${file.fsPath}:`, e);
            }
        }

        this.autoImportCache.set('stores', storeInfos);
    }

    /**
     * Obtenir tous les fichiers r√©cursivement dans un r√©pertoire
     */
    private async getFilesRecursively(dir: string, extensions: string[]): Promise<string[]> {
        const files: string[] = [];

        if (!fs.existsSync(dir)) {
            return files;
        }

        const dirEntries = fs.readdirSync(dir, { withFileTypes: true });

        for (const entry of dirEntries) {
            const entryPath = path.join(dir, entry.name);

            if (entry.isDirectory()) {
                if (entry.name === 'node_modules') continue;

                const subFiles = await this.getFilesRecursively(entryPath, extensions);

                files.push(...subFiles);
            } else if (extensions.includes(path.extname(entry.name))) {
                files.push(entryPath);
            }
        }

        return files;
    }

    /**
     * Trouver toutes les r√©f√©rences pour un composable, y compris les auto-importations
     */
    private async findAllReferences(document: vscode.TextDocument, name: string, position: vscode.Position): Promise<vscode.Location[]> {
        try {
            const results: vscode.Location[] = [];

            // Recherche standard des r√©f√©rences via VS Code
            const references = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeReferenceProvider',
                document.uri,
                new vscode.Position(position.line, position.character + name.length - 1)
            ) || [];

            // Filtrer les fichiers g√©n√©r√©s
            for (const ref of references) {
                if (!ref.uri.fsPath.includes('.nuxt') &&
                    !(ref.uri.fsPath === document.uri.fsPath && ref.range.start.line === position.line)) {
                    results.push(ref);
                }
            }

            // Utiliser findFiles pour trouver tous les fichiers pertinents dans le workspace
            const uris = await vscode.workspace.findFiles('**/*.{vue,js,ts}');

            for (const uri of uris) {
                // Ignorer les fichiers g√©n√©r√©s et le fichier courant
                if (uri.fsPath.includes('node_modules') ||
                    uri.fsPath.includes('.nuxt') ||
                    uri.fsPath.includes('.output') ||
                    uri.fsPath.includes('dist') ||
                    uri.fsPath === document.uri.fsPath) {
                    continue;
                }

                let content: string;
                try {
                    content = fs.readFileSync(uri.fsPath, 'utf-8');
                } catch {
                    continue;
                }

                // Rechercher les utilisations du composable
                const usageRegex = new RegExp(`\\b(${name}\\s*\\(|${name}\\s*<)`, 'g'); // Inclut les appels avec g√©n√©riques
                let match;

                while ((match = usageRegex.exec(content)) !== null) {
                    const matchText = match[1];
                    const index = match.index;

                    // Calculer la position √† la main
                    const start = this.indexToPosition(content, index);
                    const end = this.indexToPosition(content, index + matchText.length);

                    results.push(new vscode.Location(
                        uri,
                        new vscode.Range(
                            new vscode.Position(start.line, start.character),
                            new vscode.Position(end.line, end.character)
                        )
                    ));
                }
            }

            return results;
        } catch (e) {
            console.error('Error finding references:', e);
            return [];
        }
    }

    /**
     * Trouver toutes les r√©f√©rences pour un composant
     */
    private getNuxtComponentName(filePath: string, componentsDir: string): string {
        let relPath = path.relative(componentsDir, filePath).replace(/\.vue$/, '');

        const parts = relPath.split(path.sep);

        if (parts[parts.length - 1].toLowerCase() === 'index') {
            parts.pop();
        }

        return parts
            .filter(Boolean)
            .map(part =>
                part
                    .split('-')
                    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
                    .join('')
            )
            .join('');
    }

    /**
   * Trouver toutes les r√©f√©rences pour un composant avec surlignage pr√©cis
   */
    private async findAllDirsByName(dirName: string): Promise<string[]> {
        const dirs: string[] = [];

        if (!this.nuxtProjectRoot) return dirs;

        // Directories to check initially - including Nuxt 3 standard and Nuxt 4 compatibility mode
        const initialDirs = [
            this.nuxtProjectRoot,
            path.join(this.nuxtProjectRoot, 'app'),
            path.join(this.nuxtProjectRoot, 'app', 'base'),
            // Add other potential layer directories
            path.join(this.nuxtProjectRoot, 'app', 'modules')
        ].filter(dir => fs.existsSync(dir));

        for (const initialDir of initialDirs) {
            const recurse = (dir: string) => {
                try {
                    const entries = fs.readdirSync(dir, { withFileTypes: true });

                    for (const entry of entries) {
                        const fullPath = path.join(dir, entry.name);
                        if (entry.isDirectory()) {
                            if (entry.name === dirName) {
                                dirs.push(fullPath);
                            }
                            // Don't recurse into node_modules
                            if (entry.name !== 'node_modules' && entry.name !== '.nuxt' && entry.name !== '.output') {
                                recurse(fullPath); // continuer la r√©cursion
                            }
                        }
                    }
                } catch (e) {
                    // Ignore errors for directories that can't be read
                }
            };

            recurse(initialDir);
        }

        return dirs;
    }


    private async findAllComponentsDirs(): Promise<string[]> {
        const dirs: string[] = [];

        if (!this.nuxtProjectRoot) return dirs;

        const recurse = (dir: string) => {
            const entries = fs.readdirSync(dir, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                    if (entry.name === 'components') {
                        dirs.push(fullPath);
                    }
                    // Continue to scan subdirectories
                    recurse(fullPath);
                }
            }
        };

        recurse(this.nuxtProjectRoot);
        return dirs;
    }

    /**
   * Trouver les r√©f√©rences pour composants Nuxt
   */
    private async findComponentReferences(document: vscode.TextDocument, componentName: string): Promise<vscode.Location[]> {
        if (!this.nuxtProjectRoot) return [];

        console.log(componentName);


        // Identification du nom du composant Nuxt
        const allComponentDirs = await this.findAllComponentsDirs();
        const filePath = document.uri.fsPath;

        let nuxtComponentName = '';
        for (const dir of allComponentDirs) {
            if (filePath.startsWith(dir)) {
                nuxtComponentName = this.getNuxtComponentName(filePath, dir);
                break;
            }
        }

        if (!nuxtComponentName) return [];

        // Version kebab-case du nom du composant
        const kebab = this.pascalToKebabCase(nuxtComponentName);
        const results: vscode.Location[] = [];

        // Utiliser findFiles pour trouver tous les fichiers pertinents dans le workspace
        const uris = await vscode.workspace.findFiles('**/*.{vue,js,ts}');

        for (const uri of uris) {
            if (uri.fsPath.includes('node_modules') ||
                uri.fsPath.includes('.nuxt') ||
                uri.fsPath.includes('.output') ||
                uri.fsPath.includes('dist') ||
                path.basename(uri.fsPath) === 'app.vue' ||
                path.basename(uri.fsPath) === 'error.vue') {
                continue;
            }

            let content: string;
            try {
                content = fs.readFileSync(uri.fsPath, 'utf-8');
            } catch {
                continue;
            }

            // Recherche des balises ouvrantes avec potentiellement plusieurs lignes
            const searchPatterns = [
                // Pour le format PascalCase
                new RegExp(`<${nuxtComponentName}(\\s[\\s\\S]*?)?\\s*(/?)>`, 'gs'),
                // Pour le format kebab-case
                new RegExp(`<${kebab}(\\s[\\s\\S]*?)?\\s*(/?)>`, 'gs')
            ];

            for (const regex of searchPatterns) {
                let match;
                while ((match = regex.exec(content)) !== null) {
                    const matchText = match[0];
                    const index = match.index;

                    // Calculer la position √† la main
                    const before = content.slice(0, index);
                    const line = before.split('\n').length - 1;
                    const lineStartIndex = before.lastIndexOf('\n') + 1;
                    const col = index - lineStartIndex;

                    // Calculer la position de fin en tenant compte des sauts de ligne
                    const matchLines = matchText.split('\n');
                    const endLine = line + matchLines.length - 1;
                    const endCol = matchLines.length > 1
                        ? matchLines[matchLines.length - 1].length
                        : col + matchText.length;

                    results.push(new vscode.Location(
                        uri,
                        new vscode.Range(
                            new vscode.Position(line, col),
                            new vscode.Position(endLine, endCol)
                        )
                    ));
                }
            }
        }

        return results;
    }

    /**
     * Trouver les r√©f√©rences pour un plugin Nuxt
     */
    private async findPluginReferences(pluginName: string): Promise<vscode.Location[]> {
        if (!this.nuxtProjectRoot) return [];

        const references: vscode.Location[] = [];
        // Utilis√© pour suivre les r√©f√©rences d√©j√† ajout√©es et √©viter les duplications
        const addedReferences = new Set<string>();

        // Find the plugin file first
        const pluginUris = await vscode.workspace.findFiles(
            `**/plugins/${pluginName}.{js,ts}`,
            '**/node_modules/**'
        );

        if (pluginUris.length === 0) return references;

        const pluginPath = pluginUris[0].fsPath;
        let pluginContent: string;

        try {
            pluginContent = fs.readFileSync(pluginPath, 'utf-8');
        } catch (e) {
            return references;
        }

        // Extract provides and directives
        let provides: string[] = [];
        let hasDirectives: boolean = false;
        let directives: string[] = [];

        try {
            // 1. Classic detection via nuxtApp.provide('key', ...)
            const provideRegex = /nuxtApp\.provide\s*\(\s*['"`]([$\w]+)['"`]/g;
            let match: RegExpExecArray | null;
            while ((match = provideRegex.exec(pluginContent))) {
                provides.push(match[1]);
            }

            // 2. Advanced detection via `provide: { key: value }` including ES6 shorthand
            const provideObjectRegex = /provide\s*:\s*\{([\s\S]*?)\}/g;

            // Improved regex that captures three patterns:
            // 1. 'key': value or "key": value or `key`: value
            // 2. key: value
            // 3. key, (ES6 shorthand)
            const keyRegex = /(?:['"`]?([$\w]+)['"`]?\s*:|(\b[$\w]+),)/g;

            let provideObjectMatch: RegExpExecArray | null;
            while ((provideObjectMatch = provideObjectRegex.exec(pluginContent))) {
                const keysBlock = provideObjectMatch[1];
                let keyMatch: RegExpExecArray | null;
                while ((keyMatch = keyRegex.exec(keysBlock))) {
                    // keyMatch[1] captures the key from pattern 1 or 2
                    // keyMatch[2] captures the key from ES6 shorthand (pattern 3)
                    const key = keyMatch[1] || keyMatch[2];
                    if (key) {
                        provides.push(key);
                    }
                }
            }

            // √âliminer les doublons dans les cl√©s fournies
            provides = [...new Set(provides)];

            // 3. Detect directives
            const directiveRegex = /nuxtApp\.vueApp\.directive\s*\(\s*['"`]([\w-]+)['"`]/g;
            while ((match = directiveRegex.exec(pluginContent))) {
                hasDirectives = true;
                directives.push(match[1]);
            }

            // √âliminer les doublons dans les directives
            directives = [...new Set(directives)];

            // üîç DEBUG - show detected keys in plugins
            if (provides.length === 0 && directives.length === 0) {
                console.warn(`[PluginScanner] No provide/directive detected for ${pluginName}`);
            } else {
                console.log(`[PluginScanner] Plugin "${pluginName}" exposes:`, provides, directives);
            }
        } catch (e) {
            console.error(`[PluginScanner] Error analyzing plugin ${pluginName}:`, e);
            return references;
        }

        // Find all potential files that could reference the plugin
        const allFileUris = await vscode.workspace.findFiles(
            '**/*.{vue,js,ts}',
            '**/node_modules/**'
        );

        for (const uri of allFileUris) {
            if (uri.fsPath.includes('.nuxt') || uri.fsPath === pluginPath) continue;

            try {
                const fileContent = fs.readFileSync(uri.fsPath, 'utf-8');

                // Check for provides usage
                for (const key of provides) {
                    const patterns = [
                        new RegExp(`useNuxtApp\\(\\)\\s*\\.\\s*\\$${key}\\b`, 'g'),
                        new RegExp(`(const|let|var)\\s+\\{[^}]*\\$${key}\\b[^}]*\\}\\s*=\\s*(useNuxtApp\\(\\)|nuxtApp)`, 'g'),
                        new RegExp(`nuxtApp\\s*\\.\\s*\\$${key}\\b`, 'g'),
                        new RegExp(`Vue\\.prototype\\.\\$${key}\\b`, 'g'),
                        new RegExp(`app\\.\\$${key}\\b`, 'g'),
                        new RegExp(`this\\.\\$${key}\\b`, 'g'),
                        new RegExp(`const\\s+nuxtApp\\s*=\\s*useNuxtApp\\(\\)[^]*?\\{[^}]*\\$${key}\\b[^}]*\\}\\s*=\\s*nuxtApp`, 'gs'),
                        // Ajout pour d√©tecter la destructuration directe
                        new RegExp(`const\\s*\\{\\s*\\$${key}\\s*\\}\\s*=\\s*useNuxtApp\\(\\)`, 'g')
                    ];

                    for (const regex of patterns) {
                        let match: RegExpExecArray | null;
                        while ((match = regex.exec(fileContent))) {
                            const start = this.indexToPosition(fileContent, match.index);
                            const end = this.indexToPosition(fileContent, match.index + match[0].length);

                            // Cr√©er une cl√© unique pour cette r√©f√©rence
                            const refKey = `${uri.fsPath}:${start.line}:${start.character}:${end.line}:${end.character}`;

                            // V√©rifier si cette r√©f√©rence a d√©j√† √©t√© ajout√©e
                            if (!addedReferences.has(refKey)) {
                                addedReferences.add(refKey);
                                references.push(new vscode.Location(
                                    uri,
                                    new vscode.Range(
                                        new vscode.Position(start.line, start.character),
                                        new vscode.Position(end.line, end.character)
                                    )
                                ));
                            }
                        }
                    }
                }

                // Check for directives usage
                if (hasDirectives) {
                    for (const directive of directives) {
                        const directiveRegex = new RegExp(`\\sv-${directive}\\b|\\s:v-${directive}\\b`, 'g');
                        let match: RegExpExecArray | null;

                        while ((match = directiveRegex.exec(fileContent))) {
                            const start = this.indexToPosition(fileContent, match.index);
                            const end = this.indexToPosition(fileContent, match.index + match[0].length);

                            // Cr√©er une cl√© unique pour cette r√©f√©rence
                            const refKey = `${uri.fsPath}:${start.line}:${start.character}:${end.line}:${end.character}`;

                            // V√©rifier si cette r√©f√©rence a d√©j√† √©t√© ajout√©e
                            if (!addedReferences.has(refKey)) {
                                addedReferences.add(refKey);
                                references.push(new vscode.Location(
                                    uri,
                                    new vscode.Range(
                                        new vscode.Position(start.line, start.character),
                                        new vscode.Position(end.line, end.character)
                                    )
                                ));
                            }
                        }
                    }
                }

                // Check for direct imports of the plugin
                const importRegex = new RegExp(`import\\s+[^;]*['\`"]~/plugins/${pluginName}['\`"]`, 'g');
                let match: RegExpExecArray | null;

                while ((match = importRegex.exec(fileContent))) {
                    const start = this.indexToPosition(fileContent, match.index);
                    const end = this.indexToPosition(fileContent, match.index + match[0].length);

                    // Cr√©er une cl√© unique pour cette r√©f√©rence
                    const refKey = `${uri.fsPath}:${start.line}:${start.character}:${end.line}:${end.character}`;

                    // V√©rifier si cette r√©f√©rence a d√©j√† √©t√© ajout√©e
                    if (!addedReferences.has(refKey)) {
                        addedReferences.add(refKey);
                        references.push(new vscode.Location(
                            uri,
                            new vscode.Range(
                                new vscode.Position(start.line, start.character),
                                new vscode.Position(end.line, end.character)
                            )
                        ));
                    }
                }
            } catch (e) {
                // Ignore reading errors
            }
        }

        return references;
    }

    /**
     * Trouver les r√©f√©rences pour un middleware
     */
    private async findMiddlewareReferences(middlewareName: string): Promise<vscode.Location[]> {
        // Utiliser findFiles pour trouver toutes les pages Vue du projet
        const uris = await vscode.workspace.findFiles('**/pages/**/*.vue');
        const results: vscode.Location[] = [];

        for (const uri of uris) {
            let content: string;
            try {
                content = fs.readFileSync(uri.fsPath, 'utf-8');
            } catch {
                continue;
            }

            // Rechercher les blocs definePageMeta
            const definePageMetaRegex = /definePageMeta\s*\(\s*\{[^}]*\}/g;
            let metaMatch;

            while ((metaMatch = definePageMetaRegex.exec(content)) !== null) {
                const metaContent = metaMatch[0];
                const metaStartIndex = metaMatch.index;

                // Cas 1: middleware en tant que cha√Æne unique - middleware: 'chat'
                const singleMiddlewareRegex = new RegExp(`middleware\\s*:\\s*(['"\`])(${middlewareName})\\1`, 'g');
                let singleMatch;

                while ((singleMatch = singleMiddlewareRegex.exec(metaContent)) !== null) {
                    // Calculer la position exacte pour le middleware
                    const middlewareValueIndex = metaContent.indexOf(singleMatch[1] + middlewareName + singleMatch[1], singleMatch.index);
                    const exactIndex = metaStartIndex + middlewareValueIndex + 1; // +1 pour sauter le guillemet d'ouverture

                    // Calculer la position √† la main
                    const start = this.indexToPosition(content, exactIndex);
                    const end = this.indexToPosition(content, exactIndex + middlewareName.length);

                    results.push(new vscode.Location(
                        uri,
                        new vscode.Range(
                            new vscode.Position(start.line, start.character),
                            new vscode.Position(end.line, end.character)
                        )
                    ));
                }

                // Cas 2: middleware en tant que tableau - middleware: ['mobile-only', 'chat']
                const arrayMiddlewareRegex = /middleware\s*:\s*\[([^\]]*)\]/g;
                let arrayMatch;

                while ((arrayMatch = arrayMiddlewareRegex.exec(metaContent)) !== null) {
                    const arrayContent = arrayMatch[1];
                    const itemRegex = new RegExp(`(['"\`])(${middlewareName})\\1`, 'g');
                    let itemMatch;

                    while ((itemMatch = itemRegex.exec(arrayContent)) !== null) {
                        // Calculer la position exacte dans le tableau
                        const arrayStartIndex = metaContent.indexOf(arrayContent, arrayMatch.index);
                        const middlewareInArrayIndex = arrayContent.indexOf(itemMatch[0]);
                        const exactIndex = metaStartIndex + arrayStartIndex + middlewareInArrayIndex + 1; // +1 pour sauter le guillemet d'ouverture

                        // Calculer la position √† la main
                        const start = this.indexToPosition(content, exactIndex);
                        const end = this.indexToPosition(content, exactIndex + middlewareName.length);

                        results.push(new vscode.Location(
                            uri,
                            new vscode.Range(
                                new vscode.Position(start.line, start.character),
                                new vscode.Position(end.line, end.character)
                            )
                        ));
                    }
                }
            }
        }

        return results;
    }

    /**
     * Trouver les r√©f√©rences pour un layout
     */
    private async findLayoutReferences(layoutName: string): Promise<vscode.Location[]> {
        const uris = await vscode.workspace.findFiles('**/*.vue');
        const results: vscode.Location[] = [];

        for (const uri of uris) {
            // Utilise la lecture de fichier Node
            let content: string;
            try {
                content = fs.readFileSync(uri.fsPath, 'utf-8');
            } catch {
                continue;
            }

            const regex = new RegExp(`layout\\s*:\\s*(['"\`])${layoutName}\\1`, 'g');
            let match;
            while ((match = regex.exec(content)) !== null) {
                // Calcul position √† la main
                const start = this.indexToPosition(content, match.index);
                const end = this.indexToPosition(content, match.index + match[0].length);
                results.push(new vscode.Location(
                    uri,
                    new vscode.Range(
                        new vscode.Position(start.line, start.character),
                        new vscode.Position(end.line, end.character)
                    )
                ));
            }
        }

        return results;
    }

    private indexToPosition(content: string, index: number): { line: number, character: number } {
        const lines = content.slice(0, index).split('\n');
        const line = lines.length - 1;
        const character = lines[lines.length - 1].length;
        return { line, character };
    }

    /**
     * Trouver les r√©f√©rences pour un store
     */
    private async findStoreReferences(storeName: string): Promise<vscode.Location[]> {
        try {
            // Rechercher √† la fois par le nom du hook et le nom du store dans defineStore
            const normalizedName = storeName
                .split(/[-_\s]/)
                .map(s => s.charAt(0).toUpperCase() + s.slice(1))
                .join('');

            const storeHookName = `use${normalizedName}Store`;
            // Support pour diff√©rentes variations de nommage du store
            const possibleStoreIds = [
                storeName,
                storeName.replace(/-/g, ' '),
                storeName.replace(/-/g, '_'),
                // G√©rer aussi le cas o√π storeName est au singulier mais d√©fini au pluriel
                `${storeName}s`,
                `${storeName.replace(/-/g, ' ')}s`,
                `${storeName.replace(/-/g, '_')}s`
            ];

            const uris = await vscode.workspace.findFiles('**/*.{vue,js,ts}');
            const results: vscode.Location[] = [];
            const storeDefinitions: Map<string, string> = new Map(); // Pour stocker les id -> hookName
            const storeDefinitionFiles: Set<string> = new Set(); // Pour stocker les chemins des fichiers de d√©finition de store

            // Premi√®re passe: trouver toutes les d√©finitions de store
            for (const uri of uris) {
                if (this.shouldSkipFile(uri.fsPath)) continue;

                let content: string;
                try {
                    content = fs.readFileSync(uri.fsPath, 'utf-8');
                } catch {
                    continue;
                }

                // Chercher les d√©finitions de store
                const defineStoreRegex = /defineStore\s*\(\s*['"]([^'"]+)['"]/g;
                let defineMatch;

                while ((defineMatch = defineStoreRegex.exec(content)) !== null) {
                    const storeId = defineMatch[1];

                    // V√©rifier si ce fichier d√©finit un des stores que nous recherchons
                    if (possibleStoreIds.includes(storeId)) {
                        storeDefinitionFiles.add(uri.fsPath);
                    }

                    // Trouver le nom du hook associ√© √† cette d√©finition
                    const hookNameRegex = /const\s+(\w+)\s*=\s*defineStore\s*\(\s*['"]([^'"]+)['"]/g;
                    hookNameRegex.lastIndex = 0; // R√©initialiser l'index

                    let hookMatch;
                    while ((hookMatch = hookNameRegex.exec(content)) !== null) {
                        if (hookMatch[2] === storeId) {
                            storeDefinitions.set(storeId, hookMatch[1]);
                            break;
                        }
                    }
                }
            }

            // Deuxi√®me passe: chercher les r√©f√©rences, mais exclure les fichiers de d√©finition
            for (const uri of uris) {
                if (this.shouldSkipFile(uri.fsPath)) continue;

                // Exclure les fichiers de d√©finition du store
                if (storeDefinitionFiles.has(uri.fsPath)) continue;

                let content: string;
                try {
                    content = fs.readFileSync(uri.fsPath, 'utf-8');
                } catch {
                    continue;
                }

                // Chercher les usages du hook par nom conventionnel
                const hookRegex = new RegExp(`\\b${storeHookName}\\b`, 'g');
                this.findMatches(hookRegex, content, uri, results);

                // Chercher aussi les usages par ID de store (pour la forme `const store = useStore('store-id')`)
                for (const storeId of possibleStoreIds) {
                    const storeIdRegex = new RegExp(`useStore\\s*\\(\\s*['"]${storeId}['"]\\s*\\)`, 'g');
                    this.findMatches(storeIdRegex, content, uri, results);

                    // Chercher les usages des hooks associ√©s aux IDs trouv√©s dans la premi√®re passe
                    if (storeDefinitions.has(storeId)) {
                        const hookName = storeDefinitions.get(storeId);
                        const customHookRegex = new RegExp(`\\b${hookName}\\b`, 'g');
                        this.findMatches(customHookRegex, content, uri, results);
                    }
                }
            }

            return results;
        } catch (e) {
            console.error('Error:', e);
            return [];
        }
    }

    private shouldSkipFile(fsPath: string): boolean {
        return fsPath.includes('node_modules') ||
            fsPath.includes('.nuxt') ||
            fsPath.includes('.output') ||
            fsPath.includes('dist');
    }

    private findMatches(regex: RegExp, content: string, uri: vscode.Uri, results: vscode.Location[]): void {
        let match;
        while ((match = regex.exec(content)) !== null) {
            const start = this.indexToPosition(content, match.index);
            const end = this.indexToPosition(content, match.index + match[0].length);

            results.push(new vscode.Location(
                uri,
                new vscode.Range(
                    new vscode.Position(start.line, start.character),
                    new vscode.Position(end.line, end.character)
                )
            ));
        }
    }

    /**
     * Convertir PascalCase en kebab-case
     */
    private pascalToKebabCase(str: string): string {
        return str
            .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
            .replace(/([A-Z])([A-Z])(?=[a-z])/g, '$1-$2')
            .toLowerCase();
    }

    /**
   * Analyser les r√©pertoires d'utilitaires
   */
    private async scanUtilsDirectories(): Promise<void> {
        if (!this.nuxtProjectRoot) return;

        // Liste des dossiers potentiels √† scanner
        const utilsDirNames = ['utils', 'helpers', 'lib', 'constants', 'schemas', 'validationSchemas'];
        const utilsInfos: NuxtComponentInfo[] = [];

        for (const dirName of utilsDirNames) {
            const dirs = await this.findAllDirsByName(dirName);

            for (const dir of dirs) {
                if (!fs.existsSync(dir)) continue;

                const relativePattern = new vscode.RelativePattern(dir, '**/*.{ts,js}');
                const files = await vscode.workspace.findFiles(relativePattern);

                for (const file of files) {
                    try {
                        const content = fs.readFileSync(file.fsPath, 'utf-8');

                        // √âviter de scanner les fichiers qui contiennent des d√©finitions de store ou de composables
                        if (content.includes('defineStore') ||
                            file.fsPath.includes(path.sep + 'composables' + path.sep) ||
                            file.fsPath.includes(path.sep + 'stores' + path.sep)) {
                            continue;
                        }

                        // D√©tecter les exports
                        const exportRegex = /export\s+(const|function|async function|interface|type|enum|class)\s+(\w+)/g;
                        let match: RegExpExecArray | null;

                        while ((match = exportRegex.exec(content))) {
                            const exportType = match[1];
                            const name = match[2];

                            utilsInfos.push({
                                name: name,
                                path: file.fsPath,
                                isAutoImported: false, // Les utilitaires ne sont g√©n√©ralement pas auto-import√©s par d√©faut
                                exportType: exportType // Stocker le type d'export pour diff√©rencier
                            });
                        }
                    } catch (e) {
                        console.error(`Error scanning utils file ${file.fsPath}:`, e);
                    }
                }
            }
        }

        this.autoImportCache.set('utils', utilsInfos);
    }

    /**
   * Trouver toutes les r√©f√©rences pour un utilitaire
   */
    private async findUtilsReferences(document: vscode.TextDocument, name: string, position: vscode.Position): Promise<vscode.Location[]> {
        try {
            const results: vscode.Location[] = [];

            const uris = await vscode.workspace.findFiles('**/*.{vue,js,ts}');

            // Premi√®re passe : utiliser le provider de r√©f√©rences natif de VS Code
            const nativeReferences = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeReferenceProvider',
                document.uri,
                new vscode.Position(position.line, position.character + name.length - 1)
            ) || [];

            // Ajouter les r√©f√©rences natives filtr√©es
            for (const ref of nativeReferences) {
                if (!ref.uri.fsPath.includes('.nuxt') &&
                    !ref.uri.fsPath.includes('node_modules') &&
                    !ref.uri.fsPath.includes('.output') &&
                    !ref.uri.fsPath.includes('dist') &&
                    !(ref.uri.fsPath === document.uri.fsPath && ref.range.start.line === position.line)) {
                    results.push(ref);
                }
            }

            // Deuxi√®me passe : recherche dans tous les fichiers du workspace
            for (const uri of uris) {
                // Exclure les fichiers non pertinents
                if (uri.fsPath.includes('node_modules') ||
                    uri.fsPath.includes('.nuxt') ||
                    uri.fsPath.includes('.output') ||
                    uri.fsPath.includes('dist')) {
                    continue;
                }

                // Ignorer le fichier source
                if (uri.fsPath === document.uri.fsPath) continue;

                let content: string;
                try {
                    content = fs.readFileSync(uri.fsPath, 'utf-8');
                } catch {
                    continue;
                }

                // Rechercher les imports
                const importRegex = new RegExp(`import\\s+{[^}]*\\b${name}\\b[^}]*}\\s+from\\s+(['"\`][^'\`"]*['"\`])`, 'g');
                let match;

                while ((match = importRegex.exec(content)) !== null) {
                    const importPath = match[1].slice(1, -1); // Enlever les guillemets

                    // V√©rifier si l'import pointe vers notre fichier
                    if (this.isImportPointingToFile(importPath, uri.fsPath, document.uri.fsPath)) {
                        const nameIndex = content.indexOf(name, match.index);

                        if (nameIndex !== -1) {
                            const start = this.indexToPosition(content, nameIndex);

                            const end = this.indexToPosition(content, nameIndex + name.length);

                            results.push(new vscode.Location(
                                uri,
                                new vscode.Range(
                                    new vscode.Position(start.line, start.character),
                                    new vscode.Position(end.line, end.character)
                                )
                            ));
                        }
                    }
                }

                // Rechercher les utilisations directes (non imports)
                // 1. Pour les types / g√©n√©riques : <MyComponent<MyType>>
                const typeUsageRegex = new RegExp(`[:<]\\s*${name}(\\[\\])?\\b`, 'g');

                // 2. Pour les usages JS classiques (√©vite les strings/HTML)
                const usageRegex = new RegExp(`(?<!['"\`<>])\\b${name}\\b(?!\\s*:)`, 'g');

                // 3. Pour les bindings dans les templates Vue
                const templateBindingRegex = new RegExp(`[:@\\w\\-]+=['"]\\s*[^'"]*\\b${name}\\b[^'"]*['"]`, 'g');

                const seen = new Set<string>();

                // Pass 1 : types
                while ((match = typeUsageRegex.exec(content)) !== null) {
                    const matchStart = match.index + match[0].indexOf(name);
                    const start = this.indexToPosition(content, matchStart);
                    const end = this.indexToPosition(content, matchStart + name.length);

                    const locationKey = `${uri.fsPath}:${start.line}:${start.character}`;
                    if (!seen.has(locationKey)) {
                        seen.add(locationKey);
                        results.push(new vscode.Location(
                            uri,
                            new vscode.Range(
                                new vscode.Position(start.line, start.character),
                                new vscode.Position(end.line, end.character)
                            )
                        ));
                    }
                }

                // Pass 2 : usages JS
                while ((match = usageRegex.exec(content)) !== null) {
                    const matchStart = match.index + (match[0].length - name.length);

                    const lineStart = content.lastIndexOf('\n', matchStart) + 1;
                    const lineEnd = content.indexOf('\n', matchStart);
                    const line = content.substring(lineStart, lineEnd !== -1 ? lineEnd : content.length);

                    if (
                        line.includes('<') && line.includes('>') || // HTML
                        line.includes(`'${name}'`) || line.includes(`"${name}"`) || line.includes(`\`${name}\``)
                    ) {
                        continue;
                    }

                    const start = this.indexToPosition(content, matchStart);
                    const end = this.indexToPosition(content, matchStart + name.length);

                    const locationKey = `${uri.fsPath}:${start.line}:${start.character}`;
                    if (!seen.has(locationKey)) {
                        seen.add(locationKey);
                        results.push(new vscode.Location(
                            uri,
                            new vscode.Range(
                                new vscode.Position(start.line, start.character),
                                new vscode.Position(end.line, end.character)
                            )
                        ));
                    }
                }

                // ‚úÖ Pass 3 : templates Vue
                while ((match = templateBindingRegex.exec(content)) !== null) {
                    const matchStart = match.index + match[0].indexOf(name);
                    const start = this.indexToPosition(content, matchStart);
                    const end = this.indexToPosition(content, matchStart + name.length);

                    const locationKey = `${uri.fsPath}:${start.line}:${start.character}`;
                    if (!seen.has(locationKey)) {
                        seen.add(locationKey);
                        results.push(new vscode.Location(
                            uri,
                            new vscode.Range(
                                new vscode.Position(start.line, start.character),
                                new vscode.Position(end.line, end.character)
                            )
                        ));
                    }
                }

            }

            return results;
        } catch (e) {
            console.error('Error finding utils references:', e);
            return [];
        }
    }

    /**
     * V√©rifie si un chemin d'import pointe vers notre fichier
     */
    private isImportPointingToFile(importPath: string, importingFile: string, targetFile: string): boolean {
        // G√©rer les importations relatives et alias (~/, @/)
        if (importPath.startsWith('./') || importPath.startsWith('../')) {
            const importingDir = path.dirname(importingFile);
            const resolvedPath = path.resolve(importingDir, importPath);
            const resolvedWithExt = this.resolveWithExtension(resolvedPath);
            return resolvedWithExt === targetFile;
        } else if (importPath.startsWith('~/') || importPath.startsWith('@/')) {
            const aliasPath = importPath.substring(2); // Enlever ~/ ou @/
            const resolvedPath = path.join(this.nuxtProjectRoot!, aliasPath);
            const resolvedWithExt = this.resolveWithExtension(resolvedPath);
            return resolvedWithExt === targetFile;
        }
        return false;
    }

    /**
     * R√©soudre le chemin avec l'extension correcte
     */
    private resolveWithExtension(filePath: string): string {
        const extensions = ['.ts', '.js', '.vue'];

        // Si le chemin a d√©j√† une extension valide
        if (extensions.includes(path.extname(filePath))) {
            return filePath;
        }

        // Essayer chaque extension
        for (const ext of extensions) {
            const pathWithExt = filePath + ext;
            if (fs.existsSync(pathWithExt)) {
                return pathWithExt;
            }
        }

        // Essayer avec /index
        for (const ext of extensions) {
            const indexPath = path.join(filePath, `index${ext}`);
            if (fs.existsSync(indexPath)) {
                return indexPath;
            }
        }

        return filePath;
    }
}

export function deactivate() { }